<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script>
        const prefix = window.location.pathname.replace(/\/{2,}/g, '/');
        const currentPath = window.location.pathname.replace(/\/{2,}/g, '/');
        const baseUrl = `http://localhost${currentPath}`;
        //alert(baseUrl); 
      </script>
    <title>Pocker Planning</title>
</head>

<body>

<div><label for="step4">Step 4:</label>
    <input type="checkbox" id="step4" name="step4" onchange="updateProgressBar('step4')"></div>
<h1>Pocker Planning</h1>
    <p>Le planning poker est une façon ludique de produire des estimations sur l'effort de développement de fonctionnalités. Cette pratique est surtout utilisée en informatique, en eXtreme Programming (XP), en Scrum et dans les méthodes agiles en général pour évaluer les scénarios utilisateurs (user stories) du carnet de produit (product backlog). La méthode a été décrite pour la première fois par James Grenning1,2 en 2002 et popularisée par Mike Cohn dans le livre Agile Estimating and Planning3.

        Utilisation
        L'avantage principal du planning poker est de permettre à tous de s'exprimer librement. L'estimation serait meilleure parce que plusieurs personnes l'auront validée4 : des participants avec des niveaux d'expérience et d'expertise différents. De plus, cette technique favorise les échanges entre le responsable de produits et l'équipe de développement.
        
        L'estimation se fait en unités d'œuvre intitulées points de récits ou "journées idéales" (Ideal Day).
        
        Les points de récits permettent d'obtenir une véritable mesure relative de l'effort : les scénarios sont comparés entre eux. L'équivalent en jours-hommes est propre à chacun, selon ses compétences, son expérience et sa connaissance du domaine. L'avantage d'utiliser des points réside surtout dans le fait que l'échelle utilisée restera stable tout au long du projet. Peu importe la vitesse (vélocité) à laquelle l'équipe de développement accomplira ces tâches, nul besoin de réviser les estimations : c'est le rapport entre le temps réel et les points qui évoluera.
        
        Les avantages de l'estimation en "journées idéales" (ou heures idéale en cas de fine granularité des tâches) sont parfaitement identiques à ceux des points de récits. Par contre, l'estimation en journées idéales est plus aisée à concrétiser dans l'esprit des acteurs qui sont généralement plus à l'aise avec la notion de "journée" qu'avec un "point de récit" de taille variable pour chaque projet, qui peut aussi bien représenter quelques heures que quelques jours, et qui devra devenir une unité de référence.</p>

    </body>
</html>
<script>
 
  // Define the increment value
  let incrementValue = 12; // Set the initial value
 //Change value with method selection
   let methoddev = localStorage.getItem("val");
 
     if(methoddev == "Kanban"){
       incrementValue = 33;
     }
  
 
   // Function to update the progress bar and save the value
   function updateProgressBar(stepId) {
     // Get the step checkbox by its ID
     const stepCheckbox = document.getElementById(stepId);
 
     // Check if the step checkbox element exists
     if (!stepCheckbox) {
       console.error("Step checkbox not found!");
       return;
     }
 
     // Calculate the progress increment
     const progressIncrement = stepCheckbox.checked ? incrementValue : -incrementValue;
 
     // Retrieve the overall progress value from localStorage
     const savedProgress = localStorage.getItem("progress");
     let overallProgress = 0;
 
     if (savedProgress && !isNaN(savedProgress)) {
       overallProgress = parseInt(savedProgress, 10);
     }
 
     // Update the overall progress by adding the current progress increment
     overallProgress += progressIncrement;
 
     // Save the overall progress value to localStorage
     localStorage.setItem("progress", overallProgress.toString());
 
     // Save the checked state of the step checkbox to localStorage
     localStorage.setItem(stepId, stepCheckbox.checked ? "checked" : "unchecked");
 
     // Update the width of the progress bar
     document.getElementById("myBar").style.width = overallProgress + "%";
   }
 
   // Check if progress value exists in localStorage on page load
   document.addEventListener("DOMContentLoaded", function() {
     // Retrieve the overall progress value from localStorage
     const savedProgress = localStorage.getItem("progress");
     let overallProgress = 0;
 
     if (savedProgress && !isNaN(savedProgress)) {
       overallProgress = parseInt(savedProgress, 10);
     }
 
     // Get the step checkbox by its ID
     const stepCheckbox = document.getElementById("step4");
 
     // Check if the step checkbox element exists
     if (!stepCheckbox) {
       console.error("Step checkbox not found!");
       return;
     }
 
     // Retrieve the checked state of the step checkbox from localStorage
     const savedCheckboxValue = localStorage.getItem("step4");
     if (savedCheckboxValue === "checked") {
       stepCheckbox.checked = true;
       overallProgress += incrementValue;
     } else {
       stepCheckbox.checked = false;
     }
 
     // Update the width of the progress bar with the overall progress value
     document.getElementById("myBar").style.width = overallProgress + "%";
   });
 </script>
<script>
    const textareaContainer = document.getElementById("textarea-container");
    const textareas = textareaContainer.getElementsByTagName("textarea");
    const checkboxes = textareaContainer.querySelectorAll("input[type='checkbox']");
    
    let formValues = {};
    
    let counter = 0; // initialize counter variable
    
    for (let i = 0; i < textareas.length + checkboxes.length; i++) {
      if (i < textareas.length) {
        const textarea = textareas[i];
        const id = prefix + (counter + 1);
        textarea.id = id;
        formValues[id] = textarea.value;
        textarea.addEventListener("input", (event) => {
          formValues[id] = event.target.value;
          localStorage.setItem("formValues", JSON.stringify(formValues));
        });
        counter++; // increment counter variable
      } else {
        const checkbox = checkboxes[i - textareas.length];
        const id = prefix + (counter + 1);
        checkbox.id = id;
        formValues[id] = checkbox.checked;
        checkbox.addEventListener("change", (event) => {
          formValues[id] = event.target.checked;
          localStorage.setItem("formValues", JSON.stringify(formValues));
        });
        counter++; // increment counter variable
      }
    }
    
    const savedFormValues = localStorage.getItem("formValues");
    
    if (savedFormValues) {
      formValues = JSON.parse(savedFormValues);
      for (const id in formValues) {
        if (formValues.hasOwnProperty(id)) {
          const element = document.getElementById(id);
          if (element) {
            if (element.tagName === "TEXTAREA") {
              element.value = formValues[id];
            } else if (element.tagName === "INPUT" && element.type === "checkbox") {
              element.checked = formValues[id];
            }
          } else {
            console.warn(`Element with id "${id}" not found on page`);
          }
        }
      }
    }
    
    const updateButton = document.getElementById("update-button-all");
    updateButton.addEventListener("click", () => {
      for (let i = 0; i < textareas.length + checkboxes.length; i++) {
        const id = prefix + (i + 1);
        const element = document.getElementById(id);
        if (element) {
          if (element.tagName === "TEXTAREA") {
            formValues[id] = element.value;
          } else if (element.tagName === "INPUT" && element.type === "checkbox") {
            formValues[id] = element.checked;
          }
        } else {
          console.warn(`Element with id "${id}" not found on page`);
        }
      }
      localStorage.setItem("formValues", JSON.stringify(formValues));
      alert("Values updated!");
    });
    
    </script>